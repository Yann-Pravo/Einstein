/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g
 *     -                            On : 2011-05-27 15:22:01
 *     -                for the parser : sParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

	

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "sParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   psParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  psParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->psParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->psParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER				ctx->pParser  
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   sParserTokenNames[41+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "NB",
        (pANTLR3_UINT8) "AL",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'<?xml'",
        (pANTLR3_UINT8) "'?><kml'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'</kml>'",
        (pANTLR3_UINT8) "'<Document>'",
        (pANTLR3_UINT8) "'<name>'",
        (pANTLR3_UINT8) "'</name>'",
        (pANTLR3_UINT8) "'</Document>'",
        (pANTLR3_UINT8) "'<Style'",
        (pANTLR3_UINT8) "'<IconStyle>'",
        (pANTLR3_UINT8) "'<scale>'",
        (pANTLR3_UINT8) "'</scale>'",
        (pANTLR3_UINT8) "'<Icon>'",
        (pANTLR3_UINT8) "'<href>'",
        (pANTLR3_UINT8) "'</href>'",
        (pANTLR3_UINT8) "'</Icon>'",
        (pANTLR3_UINT8) "'</IconStyle>'",
        (pANTLR3_UINT8) "'<LabelStyle>'",
        (pANTLR3_UINT8) "'<color>'",
        (pANTLR3_UINT8) "'</color>'",
        (pANTLR3_UINT8) "'</LabelStyle>'",
        (pANTLR3_UINT8) "'</Style>'",
        (pANTLR3_UINT8) "'<Placemark>'",
        (pANTLR3_UINT8) "'</Placemark>'",
        (pANTLR3_UINT8) "'<description>'",
        (pANTLR3_UINT8) "'<![CDATA['",
        (pANTLR3_UINT8) "']]>'",
        (pANTLR3_UINT8) "'</description>'",
        (pANTLR3_UINT8) "'<styleUrl>'",
        (pANTLR3_UINT8) "'</styleUrl>'",
        (pANTLR3_UINT8) "'<Point>'",
        (pANTLR3_UINT8) "'<coordinates>'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'</coordinates>'",
        (pANTLR3_UINT8) "'</Point>'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'</'",
        (pANTLR3_UINT8) "'?'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	s    (psParser ctx, FILE * f);
static void	interior    (psParser ctx, FILE * f);
static void	contenu    (psParser ctx, FILE * f);
static void	style    (psParser ctx);
static void	placemark    (psParser ctx, FILE * f);
static void	name    (psParser ctx, FILE * f);
static void	description    (psParser ctx, FILE * f);
static void	styleUrl    (psParser ctx);
static void	point    (psParser ctx, FILE * f);
static void	fa    (psParser ctx);
static void	fu    (psParser ctx);
static void	alnum    (psParser ctx);
static void	city    (psParser ctx, FILE * f);
static void	sParserFree(psParser ctx);
static void     sParserReset (psParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new sParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psParser
sParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return sParserNewSSD(instream, NULL);
}

/** \brief Create a new sParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psParser
sParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    psParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (psParser) ANTLR3_CALLOC(1, sizeof(sParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in sParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our sParser interface
     */
    ctx->s	= s;
    ctx->interior	= interior;
    ctx->contenu	= contenu;
    ctx->style	= style;
    ctx->placemark	= placemark;
    ctx->name	= name;
    ctx->description	= description;
    ctx->styleUrl	= styleUrl;
    ctx->point	= point;
    ctx->fa	= fa;
    ctx->fu	= fu;
    ctx->alnum	= alnum;
    ctx->city	= city;
    ctx->free			= sParserFree;
    ctx->reset			= sParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = sParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
sParserReset (psParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 sParserFree(psParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return sParserTokenNames; 
}


    	

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_7_in_s45  */
static	ANTLR3_BITWORD FOLLOW_7_in_s45_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000130) };
static  ANTLR3_BITSET_LIST FOLLOW_7_in_s45	= { FOLLOW_7_in_s45_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_s47  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_s47_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000130) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_s47	= { FOLLOW_alnum_in_s47_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_8_in_s50  */
static	ANTLR3_BITWORD FOLLOW_8_in_s50_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_8_in_s50	= { FOLLOW_8_in_s50_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_s52  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_s52_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_s52	= { FOLLOW_alnum_in_s52_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_9_in_s55  */
static	ANTLR3_BITWORD FOLLOW_9_in_s55_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_9_in_s55	= { FOLLOW_9_in_s55_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interior_in_s57  */
static	ANTLR3_BITWORD FOLLOW_interior_in_s57_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_interior_in_s57	= { FOLLOW_interior_in_s57_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_10_in_s60  */
static	ANTLR3_BITWORD FOLLOW_10_in_s60_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_10_in_s60	= { FOLLOW_10_in_s60_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_11_in_interior70  */
static	ANTLR3_BITWORD FOLLOW_11_in_interior70_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_11_in_interior70	= { FOLLOW_11_in_interior70_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_interior72  */
static	ANTLR3_BITWORD FOLLOW_12_in_interior72_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002030) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_interior72	= { FOLLOW_12_in_interior72_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_interior74  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_interior74_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_interior74	= { FOLLOW_alnum_in_interior74_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_interior77  */
static	ANTLR3_BITWORD FOLLOW_13_in_interior77_bits[]	= { ANTLR3_UINT64_LIT(0x000000002000C000) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_interior77	= { FOLLOW_13_in_interior77_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contenu_in_interior79  */
static	ANTLR3_BITWORD FOLLOW_contenu_in_interior79_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_contenu_in_interior79	= { FOLLOW_contenu_in_interior79_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_interior82  */
static	ANTLR3_BITWORD FOLLOW_14_in_interior82_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_interior82	= { FOLLOW_14_in_interior82_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_style_in_contenu92  */
static	ANTLR3_BITWORD FOLLOW_style_in_contenu92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020008002) };
static  ANTLR3_BITSET_LIST FOLLOW_style_in_contenu92	= { FOLLOW_style_in_contenu92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_placemark_in_contenu95  */
static	ANTLR3_BITWORD FOLLOW_placemark_in_contenu95_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000002) };
static  ANTLR3_BITSET_LIST FOLLOW_placemark_in_contenu95	= { FOLLOW_placemark_in_contenu95_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_style108  */
static	ANTLR3_BITWORD FOLLOW_15_in_style108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_style108	= { FOLLOW_15_in_style108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_style110  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_style110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_style110	= { FOLLOW_alnum_in_style110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_9_in_style113  */
static	ANTLR3_BITWORD FOLLOW_9_in_style113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_9_in_style113	= { FOLLOW_9_in_style113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_style115  */
static	ANTLR3_BITWORD FOLLOW_16_in_style115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_style115	= { FOLLOW_16_in_style115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_style117  */
static	ANTLR3_BITWORD FOLLOW_17_in_style117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040030) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_style117	= { FOLLOW_17_in_style117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_style119  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_style119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_style119	= { FOLLOW_alnum_in_style119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_style123  */
static	ANTLR3_BITWORD FOLLOW_18_in_style123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_style123	= { FOLLOW_18_in_style123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_style125  */
static	ANTLR3_BITWORD FOLLOW_19_in_style125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_style125	= { FOLLOW_19_in_style125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_style127  */
static	ANTLR3_BITWORD FOLLOW_20_in_style127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200030) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_style127	= { FOLLOW_20_in_style127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_style129  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_style129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_style129	= { FOLLOW_alnum_in_style129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_style132  */
static	ANTLR3_BITWORD FOLLOW_21_in_style132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_style132	= { FOLLOW_21_in_style132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_style134  */
static	ANTLR3_BITWORD FOLLOW_22_in_style134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_style134	= { FOLLOW_22_in_style134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_style136  */
static	ANTLR3_BITWORD FOLLOW_23_in_style136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_style136	= { FOLLOW_23_in_style136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_style140  */
static	ANTLR3_BITWORD FOLLOW_24_in_style140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_style140	= { FOLLOW_24_in_style140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_style142  */
static	ANTLR3_BITWORD FOLLOW_25_in_style142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000030) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_style142	= { FOLLOW_25_in_style142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_style144  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_style144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_style144	= { FOLLOW_alnum_in_style144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_style147  */
static	ANTLR3_BITWORD FOLLOW_26_in_style147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_style147	= { FOLLOW_26_in_style147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_style149  */
static	ANTLR3_BITWORD FOLLOW_17_in_style149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040030) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_style149	= { FOLLOW_17_in_style149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_style151  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_style151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_style151	= { FOLLOW_alnum_in_style151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_style154  */
static	ANTLR3_BITWORD FOLLOW_18_in_style154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_style154	= { FOLLOW_18_in_style154_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_style156  */
static	ANTLR3_BITWORD FOLLOW_27_in_style156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_style156	= { FOLLOW_27_in_style156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_style158  */
static	ANTLR3_BITWORD FOLLOW_28_in_style158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_style158	= { FOLLOW_28_in_style158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_placemark170  */
static	ANTLR3_BITWORD FOLLOW_29_in_placemark170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_placemark170	= { FOLLOW_29_in_placemark170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_in_placemark172  */
static	ANTLR3_BITWORD FOLLOW_name_in_placemark172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_name_in_placemark172	= { FOLLOW_name_in_placemark172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_description_in_placemark175  */
static	ANTLR3_BITWORD FOLLOW_description_in_placemark175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_description_in_placemark175	= { FOLLOW_description_in_placemark175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_styleUrl_in_placemark178  */
static	ANTLR3_BITWORD FOLLOW_styleUrl_in_placemark178_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_styleUrl_in_placemark178	= { FOLLOW_styleUrl_in_placemark178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_point_in_placemark180  */
static	ANTLR3_BITWORD FOLLOW_point_in_placemark180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_point_in_placemark180	= { FOLLOW_point_in_placemark180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_placemark183  */
static	ANTLR3_BITWORD FOLLOW_30_in_placemark183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_placemark183	= { FOLLOW_30_in_placemark183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_name194  */
static	ANTLR3_BITWORD FOLLOW_12_in_name194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002030) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_name194	= { FOLLOW_12_in_name194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_city_in_name198  */
static	ANTLR3_BITWORD FOLLOW_city_in_name198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002030) };
static  ANTLR3_BITSET_LIST FOLLOW_city_in_name198	= { FOLLOW_city_in_name198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_name202  */
static	ANTLR3_BITWORD FOLLOW_13_in_name202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_name202	= { FOLLOW_13_in_name202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_description217  */
static	ANTLR3_BITWORD FOLLOW_31_in_description217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_description217	= { FOLLOW_31_in_description217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_description219  */
static	ANTLR3_BITWORD FOLLOW_32_in_description219_bits[]	= { ANTLR3_UINT64_LIT(0x00001C0000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_description219	= { FOLLOW_32_in_description219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fu_in_description221  */
static	ANTLR3_BITWORD FOLLOW_fu_in_description221_bits[]	= { ANTLR3_UINT64_LIT(0x00001C0000000230) };
static  ANTLR3_BITSET_LIST FOLLOW_fu_in_description221	= { FOLLOW_fu_in_description221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NB_in_description226  */
static	ANTLR3_BITWORD FOLLOW_NB_in_description226_bits[]	= { ANTLR3_UINT64_LIT(0x00001C0200000230) };
static  ANTLR3_BITSET_LIST FOLLOW_NB_in_description226	= { FOLLOW_NB_in_description226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fa_in_description228  */
static	ANTLR3_BITWORD FOLLOW_fa_in_description228_bits[]	= { ANTLR3_UINT64_LIT(0x00001C0200000230) };
static  ANTLR3_BITSET_LIST FOLLOW_fa_in_description228	= { FOLLOW_fa_in_description228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_description231  */
static	ANTLR3_BITWORD FOLLOW_33_in_description231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_description231	= { FOLLOW_33_in_description231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_description233  */
static	ANTLR3_BITWORD FOLLOW_34_in_description233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_description233	= { FOLLOW_34_in_description233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_styleUrl249  */
static	ANTLR3_BITWORD FOLLOW_35_in_styleUrl249_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_styleUrl249	= { FOLLOW_35_in_styleUrl249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alnum_in_styleUrl251  */
static	ANTLR3_BITWORD FOLLOW_alnum_in_styleUrl251_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_alnum_in_styleUrl251	= { FOLLOW_alnum_in_styleUrl251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_styleUrl254  */
static	ANTLR3_BITWORD FOLLOW_36_in_styleUrl254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_styleUrl254	= { FOLLOW_36_in_styleUrl254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_point265  */
static	ANTLR3_BITWORD FOLLOW_37_in_point265_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_point265	= { FOLLOW_37_in_point265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_point267  */
static	ANTLR3_BITWORD FOLLOW_38_in_point267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_point267	= { FOLLOW_38_in_point267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NB_in_point271  */
static	ANTLR3_BITWORD FOLLOW_NB_in_point271_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NB_in_point271	= { FOLLOW_NB_in_point271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_point273  */
static	ANTLR3_BITWORD FOLLOW_39_in_point273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_point273	= { FOLLOW_39_in_point273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NB_in_point277  */
static	ANTLR3_BITWORD FOLLOW_NB_in_point277_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NB_in_point277	= { FOLLOW_NB_in_point277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_point279  */
static	ANTLR3_BITWORD FOLLOW_39_in_point279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_point279	= { FOLLOW_39_in_point279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NB_in_point281  */
static	ANTLR3_BITWORD FOLLOW_NB_in_point281_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NB_in_point281	= { FOLLOW_NB_in_point281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_point283  */
static	ANTLR3_BITWORD FOLLOW_40_in_point283_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_point283	= { FOLLOW_40_in_point283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_point285  */
static	ANTLR3_BITWORD FOLLOW_41_in_point285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_point285	= { FOLLOW_41_in_point285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fu_in_fa302  */
static	ANTLR3_BITWORD FOLLOW_fu_in_fa302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fu_in_fa302	= { FOLLOW_fu_in_fa302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NB_in_fa304  */
static	ANTLR3_BITWORD FOLLOW_NB_in_fa304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NB_in_fa304	= { FOLLOW_NB_in_fa304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_fu312  */
static	ANTLR3_BITWORD FOLLOW_set_in_fu312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_fu312	= { FOLLOW_set_in_fu312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_alnum337  */
static	ANTLR3_BITWORD FOLLOW_set_in_alnum337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_alnum337	= { FOLLOW_set_in_alnum337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_city351  */
static	ANTLR3_BITWORD FOLLOW_set_in_city351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_city351	= { FOLLOW_set_in_city351_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start s
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:1: s[FILE * f] : '<?xml' ( alnum )* '?><kml' ( alnum )* '>' interior[f] '</kml>' ;
 */
static void
s(psParser ctx, FILE * f)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:13: ( '<?xml' ( alnum )* '?><kml' ( alnum )* '>' interior[f] '</kml>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:15: '<?xml' ( alnum )* '?><kml' ( alnum )* '>' interior[f] '</kml>'
        {
             MATCHT(7, &FOLLOW_7_in_s45); 
            if  (HASEXCEPTION())
            {
                goto rulesEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:23: ( alnum )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:23: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_s47);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */

             MATCHT(8, &FOLLOW_8_in_s50); 
            if  (HASEXCEPTION())
            {
                goto rulesEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:39: ( alnum )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:22:39: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_s52);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */

             MATCHT(9, &FOLLOW_9_in_s55); 
            if  (HASEXCEPTION())
            {
                goto rulesEx;
            }

            FOLLOWPUSH(FOLLOW_interior_in_s57);
            interior(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesEx;
            }

             MATCHT(10, &FOLLOW_10_in_s60); 
            if  (HASEXCEPTION())
            {
                goto rulesEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesEx; /* Prevent compiler warnings */
    rulesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s */

/** 
 * $ANTLR start interior
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:25:1: interior[FILE * f] : '<Document>' '<name>' ( alnum )* '</name>' contenu[f] '</Document>' ;
 */
static void
interior(psParser ctx, FILE * f)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:25:19: ( '<Document>' '<name>' ( alnum )* '</name>' contenu[f] '</Document>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:25:21: '<Document>' '<name>' ( alnum )* '</name>' contenu[f] '</Document>'
        {
             MATCHT(11, &FOLLOW_11_in_interior70); 
            if  (HASEXCEPTION())
            {
                goto ruleinteriorEx;
            }

             MATCHT(12, &FOLLOW_12_in_interior72); 
            if  (HASEXCEPTION())
            {
                goto ruleinteriorEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:25:43: ( alnum )*

            for (;;)
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:25:43: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_interior74);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinteriorEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */

             MATCHT(13, &FOLLOW_13_in_interior77); 
            if  (HASEXCEPTION())
            {
                goto ruleinteriorEx;
            }

            FOLLOWPUSH(FOLLOW_contenu_in_interior79);
            contenu(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinteriorEx;
            }

             MATCHT(14, &FOLLOW_14_in_interior82); 
            if  (HASEXCEPTION())
            {
                goto ruleinteriorEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinteriorEx; /* Prevent compiler warnings */
    ruleinteriorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end interior */

/** 
 * $ANTLR start contenu
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:1: contenu[FILE * f] : ( style )* ( placemark[f] )* ;
 */
static void
contenu(psParser ctx, FILE * f)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:19: ( ( style )* ( placemark[f] )* )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:21: ( style )* ( placemark[f] )*
        {

            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:21: ( style )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case 15:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:21: style
            	    {
            	        FOLLOWPUSH(FOLLOW_style_in_contenu92);
            	        style(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontenuEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:28: ( placemark[f] )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                case 29:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:28:28: placemark[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_placemark_in_contenu95);
            	        placemark(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontenuEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontenuEx; /* Prevent compiler warnings */
    rulecontenuEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end contenu */

/** 
 * $ANTLR start style
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:1: style : '<Style' ( alnum )* '>' '<IconStyle>' '<scale>' ( alnum )* '</scale>' '<Icon>' '<href>' ( alnum )* '</href>' '</Icon>' '</IconStyle>' '<LabelStyle>' '<color>' ( alnum )* '</color>' '<scale>' ( alnum )* '</scale>' '</LabelStyle>' '</Style>' ;
 */
static void
style(psParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:7: ( '<Style' ( alnum )* '>' '<IconStyle>' '<scale>' ( alnum )* '</scale>' '<Icon>' '<href>' ( alnum )* '</href>' '</Icon>' '</IconStyle>' '<LabelStyle>' '<color>' ( alnum )* '</color>' '<scale>' ( alnum )* '</scale>' '</LabelStyle>' '</Style>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:9: '<Style' ( alnum )* '>' '<IconStyle>' '<scale>' ( alnum )* '</scale>' '<Icon>' '<href>' ( alnum )* '</href>' '</Icon>' '</IconStyle>' '<LabelStyle>' '<color>' ( alnum )* '</color>' '<scale>' ( alnum )* '</scale>' '</LabelStyle>' '</Style>'
        {
             MATCHT(15, &FOLLOW_15_in_style108); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:18: ( alnum )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:18: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_style110);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */

             MATCHT(9, &FOLLOW_9_in_style113); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(16, &FOLLOW_16_in_style115); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(17, &FOLLOW_17_in_style117); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:53: ( alnum )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:53: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_style119);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */

             MATCHT(18, &FOLLOW_18_in_style123); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(19, &FOLLOW_19_in_style125); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(20, &FOLLOW_20_in_style127); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:90: ( alnum )*

            for (;;)
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:31:90: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_style129);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */

             MATCHT(21, &FOLLOW_21_in_style132); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(22, &FOLLOW_22_in_style134); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(23, &FOLLOW_23_in_style136); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(24, &FOLLOW_24_in_style140); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(25, &FOLLOW_25_in_style142); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:32:28: ( alnum )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:32:28: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_style144);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */

             MATCHT(26, &FOLLOW_26_in_style147); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(17, &FOLLOW_17_in_style149); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:32:56: ( alnum )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:32:56: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_style151);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */

             MATCHT(18, &FOLLOW_18_in_style154); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(27, &FOLLOW_27_in_style156); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }

             MATCHT(28, &FOLLOW_28_in_style158); 
            if  (HASEXCEPTION())
            {
                goto rulestyleEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestyleEx; /* Prevent compiler warnings */
    rulestyleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end style */

/** 
 * $ANTLR start placemark
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:35:1: placemark[FILE * f] : '<Placemark>' name[f] description[f] styleUrl point[f] '</Placemark>' ;
 */
static void
placemark(psParser ctx, FILE * f)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:35:21: ( '<Placemark>' name[f] description[f] styleUrl point[f] '</Placemark>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:35:23: '<Placemark>' name[f] description[f] styleUrl point[f] '</Placemark>'
        {
             MATCHT(29, &FOLLOW_29_in_placemark170); 
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }

            FOLLOWPUSH(FOLLOW_name_in_placemark172);
            name(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }

            FOLLOWPUSH(FOLLOW_description_in_placemark175);
            description(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }

            FOLLOWPUSH(FOLLOW_styleUrl_in_placemark178);
            styleUrl(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }

            FOLLOWPUSH(FOLLOW_point_in_placemark180);
            point(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }

             MATCHT(30, &FOLLOW_30_in_placemark183); 
            if  (HASEXCEPTION())
            {
                goto ruleplacemarkEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleplacemarkEx; /* Prevent compiler warnings */
    ruleplacemarkEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end placemark */

/** 
 * $ANTLR start name
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:38:1: name[FILE * f] : '<name>' (ville= city[f] )* '</name>' ;
 */
static void
name(psParser ctx, FILE * f)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:38:16: ( '<name>' (ville= city[f] )* '</name>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:38:18: '<name>' (ville= city[f] )* '</name>'
        {
             MATCHT(12, &FOLLOW_12_in_name194); 
            if  (HASEXCEPTION())
            {
                goto rulenameEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:38:32: (ville= city[f] )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:38:32: ville= city[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_city_in_name198);
            	        city(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */

             MATCHT(13, &FOLLOW_13_in_name202); 
            if  (HASEXCEPTION())
            {
                goto rulenameEx;
            }

            {

                		fprintf(f,",");
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenameEx; /* Prevent compiler warnings */
    rulenameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end name */

/** 
 * $ANTLR start description
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:1: description[FILE * f] : '<description>' '<![CDATA[' ( fu )* pop= NB ( fa )* ']]>' '</description>' ;
 */
static void
description(psParser ctx, FILE * f)
{   
    pANTLR3_COMMON_TOKEN    pop;

    /* Initialize rule variables
     */


    pop       = NULL;

    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:23: ( '<description>' '<![CDATA[' ( fu )* pop= NB ( fa )* ']]>' '</description>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:25: '<description>' '<![CDATA[' ( fu )* pop= NB ( fa )* ']]>' '</description>'
        {
             MATCHT(31, &FOLLOW_31_in_description217); 
            if  (HASEXCEPTION())
            {
                goto ruledescriptionEx;
            }

             MATCHT(32, &FOLLOW_32_in_description219); 
            if  (HASEXCEPTION())
            {
                goto ruledescriptionEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:53: ( fu )*

            for (;;)
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                case AL:
                case 9:
                case 42:
                case 43:
                case 44:
                	{
                		alt12=1;
                	}
                    break;

                }

                switch (alt12) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:53: fu
            	    {
            	        FOLLOWPUSH(FOLLOW_fu_in_description221);
            	        fu(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledescriptionEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */

            pop = (pANTLR3_COMMON_TOKEN) MATCHT(NB, &FOLLOW_NB_in_description226); 
            if  (HASEXCEPTION())
            {
                goto ruledescriptionEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:64: ( fa )*

            for (;;)
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                case 9:
                case 42:
                case 43:
                case 44:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:44:64: fa
            	    {
            	        FOLLOWPUSH(FOLLOW_fa_in_description228);
            	        fa(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledescriptionEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */

             MATCHT(33, &FOLLOW_33_in_description231); 
            if  (HASEXCEPTION())
            {
                goto ruledescriptionEx;
            }

             MATCHT(34, &FOLLOW_34_in_description233); 
            if  (HASEXCEPTION())
            {
                goto ruledescriptionEx;
            }

            {

                		fprintf(f,"%s,", (pop->getText(pop))->chars);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledescriptionEx; /* Prevent compiler warnings */
    ruledescriptionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end description */

/** 
 * $ANTLR start styleUrl
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:50:1: styleUrl : '<styleUrl>' ( alnum )* '</styleUrl>' ;
 */
static void
styleUrl(psParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:50:10: ( '<styleUrl>' ( alnum )* '</styleUrl>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:50:12: '<styleUrl>' ( alnum )* '</styleUrl>'
        {
             MATCHT(35, &FOLLOW_35_in_styleUrl249); 
            if  (HASEXCEPTION())
            {
                goto rulestyleUrlEx;
            }


            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:50:25: ( alnum )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case NB:
                case AL:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:50:25: alnum
            	    {
            	        FOLLOWPUSH(FOLLOW_alnum_in_styleUrl251);
            	        alnum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestyleUrlEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */

             MATCHT(36, &FOLLOW_36_in_styleUrl254); 
            if  (HASEXCEPTION())
            {
                goto rulestyleUrlEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestyleUrlEx; /* Prevent compiler warnings */
    rulestyleUrlEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end styleUrl */

/** 
 * $ANTLR start point
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:53:1: point[FILE * f] : '<Point>' '<coordinates>' eo= NB ',' ns= NB ',' NB '</coordinates>' '</Point>' ;
 */
static void
point(psParser ctx, FILE * f)
{   
    pANTLR3_COMMON_TOKEN    eo;
    pANTLR3_COMMON_TOKEN    ns;

    /* Initialize rule variables
     */


    eo       = NULL;
    ns       = NULL;

    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:53:17: ( '<Point>' '<coordinates>' eo= NB ',' ns= NB ',' NB '</coordinates>' '</Point>' )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:53:19: '<Point>' '<coordinates>' eo= NB ',' ns= NB ',' NB '</coordinates>' '</Point>'
        {
             MATCHT(37, &FOLLOW_37_in_point265); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(38, &FOLLOW_38_in_point267); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

            eo = (pANTLR3_COMMON_TOKEN) MATCHT(NB, &FOLLOW_NB_in_point271); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(39, &FOLLOW_39_in_point273); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

            ns = (pANTLR3_COMMON_TOKEN) MATCHT(NB, &FOLLOW_NB_in_point277); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(39, &FOLLOW_39_in_point279); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(NB, &FOLLOW_NB_in_point281); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(40, &FOLLOW_40_in_point283); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

             MATCHT(41, &FOLLOW_41_in_point285); 
            if  (HASEXCEPTION())
            {
                goto rulepointEx;
            }

            {

                		float NS = atof((ns->getText(ns))->chars); 
                		float EO = atof((eo->getText(eo))->chars);
                		if(NS<0) 
                		{
                			NS = NS * (-1.0);
                			fprintf(f,"%.2fS,", NS);
                		}
                		else fprintf(f,"%.2fN,", NS);
                		if(EO<0) 
                		{
                			EO = EO * (-1.0);
                			fprintf(f,"%.2fW", EO);
                		}
                		else fprintf(f,"%.2fE", EO);
                		fprintf(f,"\n");
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepointEx; /* Prevent compiler warnings */
    rulepointEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end point */

/** 
 * $ANTLR start fa
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:1: fa : ( fu | NB ) ;
 */
static void
fa(psParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:4: ( ( fu | NB ) )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:6: ( fu | NB )
        {

            // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:6: ( fu | NB )
            {
                int alt15=2;
                switch ( LA(1) ) 
                {
                case AL:
                case 9:
                case 42:
                case 43:
                case 44:
                	{
                		alt15=1;
                	}
                    break;
                case NB:
                	{
                		alt15=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 15;
                    EXCEPTION->state        = 0;


                    goto rulefaEx;
                }

                switch (alt15) 
                {
            	case 1:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:7: fu
            	    {
            	        FOLLOWPUSH(FOLLOW_fu_in_fa302);
            	        fu(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefaEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:74:10: NB
            	    {
            	         MATCHT(NB, &FOLLOW_NB_in_fa304); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefaEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefaEx; /* Prevent compiler warnings */
    rulefaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end fa */

/** 
 * $ANTLR start fu
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:75:1: fu : ( AL | '<' | '</' | '>' | '?' ) ;
 */
static void
fu(psParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:75:4: ( ( AL | '<' | '</' | '>' | '?' ) )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:75:6: ( AL | '<' | '</' | '>' | '?' )
        {
            if ( LA(1) == AL || LA(1) == 9 || ((LA(1) >= 42) && (LA(1) <= 44)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_fu312;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_fu312);    goto rulefuEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefuEx; /* Prevent compiler warnings */
    rulefuEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end fu */

/** 
 * $ANTLR start alnum
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:76:1: alnum : ( AL | NB ) ;
 */
static void
alnum(psParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:76:7: ( ( AL | NB ) )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:76:9: ( AL | NB )
        {
            if ( ((LA(1) >= NB) && (LA(1) <= AL)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_alnum337;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_alnum337);    goto rulealnumEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealnumEx; /* Prevent compiler warnings */
    rulealnumEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end alnum */

/** 
 * $ANTLR start city
 * /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:77:1: city[FILE * f] : n= ( AL | NB ) ;
 */
static void
city(psParser ctx, FILE * f)
{   
    pANTLR3_COMMON_TOKEN    n;

    /* Initialize rule variables
     */


    n       = NULL;

    {
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:77:16: (n= ( AL | NB ) )
        // /etudiant/jerome.audoux/Téléchargements/ANTLR2/s.g:77:18: n= ( AL | NB )
        {
            n=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= NB) && (LA(1) <= AL)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_city351;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_city351);    goto rulecityEx;
            }

            {

                			fprintf(f,"%s",(n->getText(n))->chars);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecityEx; /* Prevent compiler warnings */
    rulecityEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end city */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
